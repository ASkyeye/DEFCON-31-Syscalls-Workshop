If you take a closer look at the technical structure of the Windows 10 architecture, you will notice that the Ntdll.dll in user mode represents the lowest common denominator before the transition to the Windows kernel. For this reason, some well-known EDRs place their inline hooks in specially selected native APIs in Ntdll.dll. Ok, if it's that simple, then an EDR could just hook into all the Native APIs and make life hell for us Red Teamers. Fortunately, from a Red Teamer's point of view, this is not possible for performance reasons. Simply put, hooking APIs costs resources, time, etc., and the more an EDR slows down an OS, the worse it is for the EDR.

As a result, EDRs typically only hook select APIs that are often abused by attackers in conjunction with malware. These include native APIs such as NtAllocateVirtualMemory and NtWriteVirtualMemory.
![image](https://user-images.githubusercontent.com/50073731/235348184-27c441ae-6466-406b-8343-0f7ab1f12843.png)

If you want to check your own EDR to see if it or which APIs are redirected to the EDR's own Hooking.dll by inline hooking, you can use a debugger such as Windbg. To do this, start a program on the endpoint with EDR installed, e.g. Notepad, and then connect to the running process via Windbg. Note that if you make the same mistake as I did at the beginning and load notepad.exe directly as an image into the debugger, you will not find any hooks in the APIs, because in this case the EDR has not yet been able to inject its Hooking.dll into the address space of notepad.exe.The following figure shows a comparison between an endpoint with no EDR installed and no hook, and an endpoint with EDR installed that uses user mode inline hooking for Native APIs in Ntdll.dll. On the endpoint with EDR installed, the 5-byte jump instruction (jmp) is clearly visible. As mentioned earlier, this instruction causes a redirection to the EDR's Hooking.dll before returning to the Ntdll.dll and executing the system call.
![image](https://user-images.githubusercontent.com/50073731/235348270-8dfdf69e-5ac0-468f-832d-c50b57f3fc72.png)

If you want to be sure that the jump instruction really causes a redirect to the EDR's Hooking.dll, you can check this with e.g. x64dbg. If you follow the address of the jump instruction of a hooked API, e.g. NtAllocateVirtualMemory in memory (Follow in Dissasembler), you will see the redirect to the EDR's Hooking.dll. The name of the "Hooking.dll" is intentionally pixelated so that the EDR cannot be identified.
![image](https://user-images.githubusercontent.com/50073731/235348295-93a8d575-f21a-4ce1-8f19-1107e39a435f.png)
